Wouldn't it be nice to do the programming competition again this year? I have 
an idea that's simple enough for the non-programmer to have a good chance at 
winning yet allows deep complexity for anyone keen to get their hands dirty.

The Game
--------
My idea is inspired by the classic iterated Prisoner's Dilemma problem in game 
theory. The premise is to write an "agent" to survive and thrive in the morally 
bankrupt RockPaperScissors (RPS) land.

Your agent spends its life in a dystopian RPS underworld, where at any moment 
another agent could pick a fight with it, after which your agent is obliged to 
pick a fight with yet another. In RPS battle, the instigating agent gets a 
chance (which he must use) to tell the truth or lie about which tool he is 
going to use (rock, paper, or scissors). Agents start off with 10 points, and 
gain and lose points when they win, lose and tie a round depending on the 
circumstances of the fight. The points table is in the technicalities 
document:

http://shmookey.ucc.asn.au/technicalities

Synopsis: if an agent gets picked on for a fight and told rock, paper or 
scissors, it can either get modest but mutually beneficial points by trying to 
cause a tie, but risk being slaughtered by the other if it's lying (with a 
small amount of points awarded if it wins "by accident"), or it can try to win 
based on that information and get big points for exploiting the other agent 
with a relatively small punishment for being "tricked" and losing (and no point 
change in case of an "accidental" tie).

Thus, in any single round there are bigger rewards and smaller consequences in 
"attacking" the rock, paper or scissors that the enemy agent claims it will 
use, but cooperation leads to mutual benefit and good agents should turn 
against agents that try to exploit them.

If the agent loses all its points, it dies. If it reaches 20 points, it forms a 
new agent and both return to 10 points. The agent can remember who it has 
battled in the past and what the other agent has done, but it has no way of 
communicating this to any other agent, and any "children" of the agent don't 
inherit this memory.

Winning Conditions
------------------
The object of the game is for the descendants of your agent to be the dominant 
species in an evolutionarily stable environment. The environment is declared 
evolutionarily stable when the proportions of species populations remains the 
same (with a tolerance of 5%) over ten thousand iterations, or if there is only 
once species remaining, or if the judges say so.

There will be a prize for the winner consisting of whatever we can scrounge up 
plus a special certificate you can keep forever and frame and love. Entrants 
whose species survive to evolutionary stability will also receive a 
certificate.

Entry Cost
----------
The cost of entry per person is $3 for UCC members and $5 for everyone else. 
Your entry may contain one (1) agent and you may only enter once. UCC reserves 
the right to withdraw any agent without refund if it causes technical or 
administrative difficulty, after a reasonable attempt at resolution is made.

Non-Programmers and Beginners
-----------------------------
There will be simple sample agents available that demonstrate how easy it 
is to turn your idea into code. If you're able to visualise your idea as a 
series of instructions you might tell a small child, you'll be able to 
make it into an agent.

If you don't understand the next section, don't worry, modifying the samples to 
do your bidding will work just as well as writing your agent from scratch.

Technical Details
-----------------
The challenge will be operated by a supervisor module that picks the fights in 
a "fair" way such that each agent gets to fight every other agent (supposing no 
agents die) and each agent gets to see battle as frequently as possible. The 
supervisor will be able to do any number of iterations in one go, after which 
statistics can be gathered before doing the next set of iterations.

The easiest way to create an agent is with Python. Python is a popular 
scripting language with a simple, easy to pick up syntax that resembles 
pseudocode, and is well-adapted to this kind of task. Another advantage to 
using Python is that the supervisor can talk to the agent directly, and the 
programmer will not have to worry about maintaining state or validating input 
and output. A Python agent should be a class that implements at least the 
specification laid out in the technicalities document:

http://shmookey.ucc.asn.au/technicalities

The supervisor will store the number of points the agent has and the 
number of children for your convenience. Your module may use any resource 
available in the standard Python distribution. You are expected to use 
member variables of your class to keep state.

You can use any language you like for your agent, really. Interfacing to 
non-python agents is via stdin/stdout, so your language's builtin print and 
read functions will work, but beware: if an agent makes a single mistake in its 
input or output, the supervisor will declare it insane - which in 
RockPaperScissors land carries the death penalty. The format of the input and 
output is documented in the technicalities document:

http://shmookey.ucc.asn.au/technicalities

The agent is run once per instance and is expected to maintain its own state. 
Not maintaining state correctly could lead to a very confused agent, left 
wondering why it's not dead, or why the baby hasn't come. Don't leave your 
agent wondering.

A sample agent in Python, Java and C will be provided. Your agent does not have 
to be open-source, but it must be submitted as source-code to prevent cheating. 
If the agent is not in Python, build instructions must also be submitted.

